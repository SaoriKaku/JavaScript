<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
    运算符也叫操作符，通过运算可以对一个或多个值进行运算
    比如：typeof就是运算符，可以来获得一个值的类型，它会将该值的类型以字符串形式返回
    1. 算数运算符
    当对非Number类型的值进行运算时，会将这些值转换为Number在进行计算
    任何值和NaN做运算都得NaN
    + 
    1. 可以对两个值进行加法运算，并将结果返回；
    2. 如果对两个字符串进行加法运算，则会做拼串；
    3. 任何值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作。
    4. 为任意数据类型 + ""，即可将其转换为String
    这是一种隐式的类型转换，由浏览器自动完成，实际上它是调用了String()
    result = 1 + 2 + "3"; // 33
    result = "1" + 2 + 3; // 123
    - 减法运算
    * 乘法运算
    / 不是取整，可以有小数
    任何值做- * /运算时都会自动转换为Number，它的原理和Number()一样
    我们可以利用这一特点做隐式的类型转换
    可以通过一个值 -0 *1 /1来将其转换为Number
    % 取余数

    2. 一元运算符
    正号：正好不会对数字产生任何影响
    负号：负号可以对数字进行负号的取反
    对于非Number类型的值：
    它会先转换为Number，然后再运算
    可以对一个其他的数据类型使用+，来将其转换为number，它的原理和Number()一样
    var result = 1 + "2" + 3; // 123 string
    var result = 1 + +"2" + 3; // 6 number

    3. 自增和自减
    通过自增可以使变量在自身的基础上增加1，对于一个变量自增以后，原变量的值会立即自增1
    自增分为两种：a++, ++a
    无论是a++还是++a，都会立即使得原变量的值自增1
    不同的是a++和++a的值不同，
    a++的值=原变量的值（自增前的值），
    ++a的值=原变量的新值（自增后的值）
    var a = 10;
    console.log(a++); // 10 a = 11
    console.log(a++); // 11 a = 12
    console.log(++a); // 13 a = 13
    console.log(++a); // 14 a = 14
    var d = 20;
    var result = d++ + ++d + d; // result = 20 + 22 + 22 = 64
    d = d++; // d++ = 20, d = 21, d = d++ = 20

    自减--
    通过自减可以使变量在自身的基础上减1
    自减分成两种：a--, --a
    无论是a--还是--a，都会立即使得原变量的值自减1
    不同的是a--和--a的值不同，
    a--的值=原变量的值（自增前的值），
    --a的值=原变量的新值（自增后的值）

    4. 逻辑运算符
    1. ！非
    如果对非布尔值进行取反，将其转换为布尔值然后取反。
    将一个其他的数据类型转换为布尔值，可以为一个任意数据类型取两次反，将其转换为布尔值
    原理和Boolean()函数一样。
    对于非布尔值进行与或运算，会将其转换为布尔值，然后再运算。
    2. && 与
    true && true，两个值都为true，则返回后面的值
    false && false, 两个值都为false, 则返回前面的值
    true && false, 返回false的值
    var result = 2 && 1; // result = 1
    如果第一个值为true，则直接返回第二个值
    如果第一个值为false，则直接返回第一个值
    3. || 或
    如果第一个值为true，则直接返回第一个值
    如果第一个值为false，则直接返回第二个值

    5. 比较运算符
    对于非数值进行比较时，会将其转换为数字然后比较
    任何值和NaN比较都是false
    console.log(1 > "0"); // 1 > 0, true
    console.log(10 > null); // 10 > 0, true
    console.log(10 <= "hello"); // 10 <= NaN, false
    比较两个字符串时，比较的是字符串的Unicode
    比较字符编码时是一位一位进行比较，如果两位一样则比较下一位
    所以借用它对英文进行排序
    console.log("11" < "5"); // true

    6. Unicode
    在js中使用转义字符输入Unicode编码：\u + 四位编码（这里是16进制）
    在html中使用Unicode编码：&# + 编码（必须是10进制）
    console.log("\u2620");
    <h1 style="font-size: 100px">&#9760;</h1>

    7 ==
    当两个类型不同时，会转换成相同类型在比较，通常是转换为数字，但不一定
    console.log(true == "1"); // 都转化为1, true
    console.log(null == 0); // 不知道转化为什么, false
    undefined衍生自null，所以这两个值作比较时，会返回true
    console.log(null == undefined); // true
    NaN不和任何值相等，包括它本身
    可以通过isNaN()函数来判断一个值是否是NaN，如果是则返回true，否则返回false
    === 全等
    如果两个值的类型不同，直接返回false，不会做类型转换。
     -->
</body>
</html>