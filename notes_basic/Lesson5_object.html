<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
    1. 对象的分类
    1. 内建对象
    由ES标准中定义的对象，在任何的ES的实现中都可以使用
    比如：Math, String, Number, Boolean, Function, Object
    2. 宿主对象
    由JS的运行环境提供对象，目前来讲主要指由浏览器提供的对象，比如：BOM DOM
    3. 自定义对象
    由开发人员自己创建的对象

    2. 查改增删
    1. 创建对象
    使用new关键字调用的函数，是构造函数constructor
    使用typeof检查一个对象时，会返回Object
    var obj = new Object();
    2. 在对象中保存的值成为属性
    向对象添加属性：语法：对象.属性名 = 属性值
    3. 读取对象中的属性
    语法：对象.属性名
    如果读取的对象中没有该属性，不会报错而是会返回undefined
    4. 修改对象的属性值
    语法：对象.属性名 = 新值
    5. 删除对象的属性
    语法：delete 对象.属性名

    3. 属性名
    1. 如果要使用特殊的属性名，不能采用.的方式来操作
    需要使用另一种方式，语法：对象["属性名"] = 属性值，读取也需要采用这种方式
    使用[]操作属性，更加灵活，在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性
    2. js对象的属性值可以是任意的数据类型，甚至也可以是一个对象。

    4. in运算符
    通过该运算符可以检查一个对象中是否含有指定的属性
    如果有则返回true，没有则返回false
    语法："属性名"（这个必须是String） in 对象
    console.log("test" in obj);

    5. 基本数据类型的值直接在栈内存中存储，值与值之间独立存在，修改一个变量不会影响其他变量
    对象是保存到堆内存中，每创建一个新的对象，就会在堆内存中开辟出一个新的空间
    变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用
    当一个通过一个变量修改属性时，另一个也会受到影响。
    当比较两个基本数据类型的值时，就是比较值；
    挡比较两个引用数据类型时，它比较的是对象的内存地址；
    如果两个对象是一模一样，但是地址不同，它也会返回false。

    6. 使用对象字面量，可以在创建对象时，直接指定对象中的属性。
    语法：{属性名:属性值, 属性名:属性值...}
    对象字面量的属性名可以加引号也可以不加，建议不加
    如果要使用一些特殊的字符，则必须加引号

    7. 使用工厂方法创建对象
    function createPerson(name, age, gender) {
        var obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.gender = gender;
        obj.sayName = function() {
            alert(this.name);
        };
        return obj;
    }

    8. 构造函数
    1. 创建一个构造函数，专门用来创建Person对象。
    构造函数是一个普通的函数，创建方式和普通函数没有区别。不同的是首字母习惯上大写。
    构造函数和普通函数区别就是调用方式不同。普通函数直接调用，构造函数需要使用new关键字来调用。
    2. 构造函数的执行流程：
        1. 立刻创建一个新的对象
        2. 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象
        3. 逐行执行函数中的代码
        4. 将新建的对象作为返回值返回
    function Person(name, age, gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.sayName = function() {
            alert(this.name);
        };
    }
    var per1 = Person("John", 18, "male");
    var per2 = Person("Rose", 20, "female");
    console.log(per1.sayName == per2.sayName); // false
    3. 使用同一个构造函数创建的对象，成为一类对象，也将一个构造函数称为一个类。
    我们将通过一个构造函数创建的对象，称为是该类的实例。
    4. 使用instanceof可以检查一个对象是否是一个类的实例
    语法：对象 instanceof 构造函数，如果是则返回true，否则返回false
    5. 所有对象都是object后代，任何对象和object做instanceof检查都会返回true
    6. 目前我们的方法在构造函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法
    也就是所有实例的sayName都是唯一的，这样就导致了构造函数执行一次就会创建一个新的方法。
    执行1000次就会创建1000个新的方法，而1000个方法都是一模一样的，完全可以使所有对象共享同一个方法。
    function Person(name, age, gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.sayName = fun;
    }
    function fun() {
        alert(this.name);
    }
    var per1 = new Person("John", 18, "male");
    var per2 = new Person("Rose", 20, "female");
    console.log(per1.sayName == per2.sayName); // true
     -->
</body>
</html>